<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>AR Tetris</title>
    <!--
      MODIFICATION:
      Replaced local file paths with CDN links to make this
      a single, self-contained HTML file that works anywhere.
    -->
    <script src="https://github.com/vickeyviswanathan/tetris/blob/main/three.min.js"></script>
    <script src="https://github.com/vickeyviswanathan/tetris/blob/main/Tone.js"></script>
    
    <style>
        body {
            /* Replaced 'Orbitron' with a standard monospace font stack */
            font-family: Consolas, 'Courier New', monospace;
            background-color: #000000;
            color: #ffffff;
            overflow: hidden;
            margin: 0;
            padding: 0;
            touch-action: none;
        }
        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #game-canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        .screen-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            backdrop-filter: blur(10px);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
        }
        .screen-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .title {
            font-size: clamp(3rem, 15vw, 8rem);
            font-weight: 700;
            color: #00ffff;
            text-align: center;
            text-shadow:
                0 0 5px #00ffff, 0 0 10px #00ffff, 0 0 20px #00ffff,
                0 0 40px #ff00ff, 0 0 70px #ff00ff, 0 0 80px #ff00ff, 0 0 100px #ff00ff;
            animation: flicker-title 2s infinite alternate;
        }
        .button {
            margin-top: 2rem;
            padding: 1rem 2rem;
            font-size: clamp(1.2rem, 5vw, 2rem);
            color: #00ffff;
            background: transparent;
            border: 3px solid #00ffff;
            border-radius: 8px;
            cursor: pointer;
            text-shadow: 0 0 5px #00ffff;
            box-shadow: 0 0 10px #00ffff inset, 0 0 10px #00ffff;
            transition: all 0.2s ease-in-out;
            animation: pulse-button 2s infinite ease-in-out;
        }
        .button:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
        }
        @keyframes pulse-button {
            0% { transform: scale(1); box-shadow: 0 0 10px #00ffff inset, 0 0 10px #00ffff; }
            50% { transform: scale(1.05); box-shadow: 0 0 20px #00ffff inset, 0 0 30px #00ffff, 0 0 50px #ff00ff; }
            100% { transform: scale(1); box-shadow: 0 0 10px #00ffff inset, 0 0 10px #00ffff; }
        }
        @keyframes flicker-title {
            to {
                text-shadow:
                    0 0 5px #00ffff, 0 0 10px #00ffff, 0 0 20px #00ffff,
                    0 0 40px #0000ff, 0 0 70px #0000ff, 0 0 80px #0000ff, 0 0 100px #0000ff;
            }
        }
        .game-ui {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-wrap: nowrap; /* Forces single line */
            white-space: nowrap; /* Prevents internal wrapping */
            justify-content: center;
            gap: 1rem 2.5rem; /* Increased gap */
            padding: 10px 25px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            /* font-family removed to inherit from body */
            font-size: clamp(1rem, 2.5vw, 1.3rem);
            text-align: center;
            z-index: 10;
            color: #00ffff;
            font-weight: 400; /* Regular weight for this font is clearer */
            text-shadow: 0 0 6px #00ffff;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
        }
        .game-ui.visible {
            opacity: 1;
            visibility: visible;
        }
        .final-stats {
            margin-top: 2rem;
            font-size: clamp(1rem, 4vw, 1.8rem);
            text-align: center;
            color: #90EE90;
            text-shadow: 0 0 5px #90EE90;
        }
        
        /* --- Styles for classes previously handled by Tailwind --- */
        #start-screen p {
            margin-top: 2rem; /* mt-8 */
            font-size: 1.125rem; /* text-lg */
            color: #9CA3AF; /* text-gray-400 */
        }
        
        footer {
            position: absolute;
            bottom: 0.5rem; /* bottom-2 */
            left: 0; /* left-0 */
            right: 0; /* right-0 */
            text-align: center; /* text-center */
            color: #6B7281; /* text-gray-500 */
            font-size: 0.75rem; /* text-xs */
            z-index: 30; /* z-30 */
            opacity: 0.5; /* opacity-50 */
            /* font-family removed to inherit from body */
        }
        /* --- End of replaced styles --- */
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="game-canvas"></canvas>
    </div>

    <!-- UI Panel -->
    <div id="game-ui" class="game-ui">
        <span>HIGHSCORE: <span id="highscore">0</span></span>
        <span>SCORE: <span id="score">0</span></span>
        <span>LINES: <span id="lines">0</span></span>
        <span>LEVEL: <span id="level">1</span></span>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="screen-overlay visible">
        <h1 class="title">AR TETRIS</h1>
        <button id="start-button" class="button">START GAME</button>
        <!-- Removed Tailwind classes from this <p> tag -->
        <p>Swipe to Move | Tap to Rotate | Swipe Down to Drop</p>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen-overlay">
        <h1 class="title" style="color:#ff0000; text-shadow: 0 0 7px #ff0000, 0 0 21px #ff0000, 0 0 82px #ff4500;">GAME OVER</h1>
        <div class="final-stats">
            <p>High Score: <span id="final-highscore">0</span></p>
            <p>Final Score: <span id="final-score">0</span></p>
        </div>
        <button id="restart-button" class="button" style="border-color:#ff0000; text-shadow:0 0 5px #ff0000; box-shadow: 0 0 10px #ff0000 inset, 0 0 10px #ff0000;">PLAY AGAIN</button>
    </div>

    <!-- Removed Tailwind classes from this <footer> tag -->
    <footer>
        Created by Vivek Viswanathan
    </footer>

    <script>
        // --- SETUP & STATE ---
        let scene, camera, renderer;
        let gameState = 'start';
        const gameContainer = document.getElementById('game-container');
        
        const gameWorld = new THREE.Group();

        const GRID_WIDTH = 10;
        const GRID_HEIGHT = 20;
        const CUBE_SIZE = 1; 

        let logicalGrid = [];
        let visualBlocks = [];
        let currentPiece;
        let score = 0, lines = 0, level = 1, highScore = 0;
        let dropInterval = 1000, lastDropTime = 0;
        let stars, nebula, spaceDust;

        const ui = {
            game: document.getElementById('game-ui'),
            highscore: document.getElementById('highscore'),
            score: document.getElementById('score'),
            lines: document.getElementById('lines'),
            level: document.getElementById('level'),
            startScreen: document.getElementById('start-screen'),
            startButton: document.getElementById('start-button'),
            gameOverScreen: document.getElementById('game-over-screen'),
            finalScore: document.getElementById('final-score'),
            finalHighscore: document.getElementById('final-highscore'),
            restartButton: document.getElementById('restart-button')
        };
        
        // --- AUDIO ENGINE ---
        let synths = {};
        let musicPattern;

        function initializeAudio() {
            // This code will only run *after* tone.js has successfully loaded
            synths = {
                move: new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination(),
                rotate: new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(),
                drop: new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 4, envelope: { attack: 0.001, decay: 0.2, sustain: 0 } }).toDestination(),
                clear: new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.2 } }).toDestination(),
                gameOver: new Tone.Synth({ oscillator: { type: "fmsine" }, envelope: { attack: 0.1, decay: 0.5, sustain: 0.1, release: 1 } }).toDestination(),
                music: new Tone.MonoSynth({ volume: -20, oscillator: { type: "pulse", width: 0.6 }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.4, release: 0.8 }, filterEnvelope: { attack: 0.05, decay: 0.1, sustain: 0.2, release: 0.8, baseFrequency: 300, octaves: 4 } }).toDestination()
            };
            musicPattern = new Tone.Pattern((time, note) => synths.music.triggerAttackRelease(note, "8n", time), ["C3", "E3", "G3", "B3"], "upDown");
            musicPattern.interval = "8n";
        }

        function playSound(sound) {
            if (!synths.move || Tone.context.state !== 'running') return; // Check if synths are initialized
            try {
                switch(sound) {
                    case 'move': synths.move.triggerAttackRelease("C3", "8n"); break;
                    case 'rotate': synths.rotate.triggerAttackRelease("G4", "16n"); break;
                    case 'drop': synths.drop.triggerAttackRelease("C2", "8n"); break;
                    case 'clear': synths.clear.triggerAttackRelease("C5", "8n"); break;
                    case 'tetris': synths.clear.triggerAttackRelease("G5", "4n"); break;
                    case 'gameOver': synths.gameOver.triggerAttackRelease("C2", "1n"); break;
                }
            } catch (e) {
                console.warn("Audio playback error:", e);
            }
        }
        
        // --- PIECE DEFINITIONS ---
        const TETROMINOES = {
            'I': { shape: [[1, 1, 1, 1]], color: 0x00ffff },
            'J': { shape: [[1, 0, 0], [1, 1, 1]], color: 0x0000ff },
            'L': { shape: [[0, 0, 1], [1, 1, 1]], color: 0xffa500 },
            'O': { shape: [[1, 1], [1, 1]], color: 0xffff00 },
            'S': { shape: [[0, 1, 1], [1, 1, 0]], color: 0x00ff00 },
            'T': { shape: [[0, 1, 0], [1, 1, 1]], color: 0x800080 },
            'Z': { shape: [[1, 1, 0], [0, 1, 1]], color: 0xff0000 }
        };
        const PIECE_TYPES = 'IJLOSTZ';

        // --- CORE INITIALIZATION ---
        // This code will only run *after* three.min.js has successfully loaded
        function init() {
            scene = new THREE.Scene();

            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('game-canvas') });
            
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);

            scene.add(new THREE.AmbientLight(0xffffff, 0.2));
            const light = new THREE.PointLight(0xffffff, 0.8);
            light.position.set(GRID_WIDTH / 2, GRID_HEIGHT, 10);
            scene.add(light);

            gameWorld.scale.set(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
            gameWorld.position.set(-GRID_WIDTH / 2, -GRID_HEIGHT / 2, 0);
            scene.add(gameWorld);
            
            const gridMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.25 });
            for (let x = 0; x <= GRID_WIDTH; x++) {
              const points = [ new THREE.Vector3(x, 0, 0.001), new THREE.Vector3(x, GRID_HEIGHT, 0.001) ];
              gameWorld.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), gridMaterial));
            }
            for (let y = 0; y <= GRID_HEIGHT; y++) {
              const points = [ new THREE.Vector3(0, y, 0.001), new THREE.Vector3(GRID_WIDTH, y, 0.001) ];
              gameWorld.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), gridMaterial));
            }

            const createParticleLayer = (count, size, color, speed) => {
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(count * 3);
                for (let i = 0; i < pos.length; i++) { pos[i] = (Math.random() - 0.5) * 200; }
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({ size, color, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false, opacity: 0.7 });
                const points = new THREE.Points(geo, mat);
                points.userData.speed = speed;
                return points;
            };
            stars = createParticleLayer(8000, 0.05, 0xffffff, 0.01);
            nebula = createParticleLayer(500, 5, 0x0000ff, 0.05);
            spaceDust = createParticleLayer(12000, 0.02, 0xaaaaaa, 0.03);
            scene.add(stars, nebula, spaceDust);

            // Initialize audio here, now that Tone.js is loaded
            initializeAudio();

            ui.startButton.addEventListener('click', startGame);
            ui.restartButton.addEventListener('click', startGame);

            window.addEventListener('resize', onWindowResize);
            addControls();
            
            loadHighScore();
            onWindowResize();
            animate();
        }

        // --- GAME FLOW ---
        async function startGame() {
            if (Tone.context.state !== 'running') {
                try {
                    await Tone.start();
                    console.log("Audio context started");
                } catch (e) {
                    console.warn("Could not start audio context:", e);
                }
            }
            
            // Reset camera for gameplay
            camera.position.set(0, 0, 50);
            camera.lookAt(scene.position);

            gameState = 'playing';
            ui.startScreen.classList.remove('visible');
            ui.gameOverScreen.classList.remove('visible');
            ui.game.classList.add('visible');
            
            logicalGrid = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(0));
            redrawGrid();
            if (currentPiece) currentPiece.removeFromScene();

            score = 0; lines = 0; level = 1;
            dropInterval = 1000;
            updateUI();
            
            spawnNewPiece();
            
            try {
                Tone.Transport.start();
                musicPattern.start(0);
            } catch (e) {
                console.warn("Could not start music:", e);
            }
        }

        function gameOver() {
            gameState = 'gameover';
            playSound('gameOver');
            try {
                musicPattern.stop(); 
                Tone.Transport.stop();
            } catch(e) {
                console.warn("Could not stop music:", e);
            }

            if (score > highScore) { highScore = score; saveHighScore(); }

            ui.finalScore.textContent = score;
            ui.finalHighscore.textContent = highScore;
            ui.game.classList.remove('visible');
            ui.gameOverScreen.classList.add('visible');
        }

        function loadHighScore() {
            try {
                const savedScore = localStorage.getItem('neonTetrisHighScore');
                highScore = savedScore ? parseInt(savedScore, 10) : 0;
                ui.highscore.textContent = highScore;
            } catch(e) {
                console.warn("Could not load high score from localStorage:", e);
                highScore = 0;
                ui.highscore.textContent = 0;
            }
        }

        function saveHighScore() {
             try {
                localStorage.setItem('neonTetrisHighScore', highScore);
             } catch (e) {
                console.warn("Could not save high score to localStorage:", e);
             }
        }

        // --- STABILIZED GAME LOGIC ---

        function isValidPosition(shape, checkX, checkY) {
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x] === 1) {
                        const absoluteX = checkX + x;
                        const absoluteY = checkY - y;

                        if (absoluteX < 0 || absoluteX >= GRID_WIDTH || absoluteY < 0) {
                            return false;
                        }
                        
                        if (absoluteY < GRID_HEIGHT && logicalGrid[absoluteY] && logicalGrid[absoluteY][absoluteX] !== 0) {
                           return false;
                        }
                    }
                }
            }
            return true;
        }

        class Tetromino {
            constructor(shape, color, x, y) {
                this.shape = shape;
                this.color = color;
                this.x = x;
                this.y = y;
                this.blocks = [];
                this.draw();
            }

            draw() {
                this.removeFromScene();
                const cubeGap = 0.04;
                const geometry = new THREE.BoxGeometry(1 - cubeGap, 1 - cubeGap, 1 - cubeGap);
                const material = new THREE.MeshLambertMaterial({ color: this.color, emissive: this.color, emissiveIntensity: 1.3 });
                
                this.shape.forEach((row, y_offset) => {
                  row.forEach((value, x_offset) => {
                    if (value) {
                      const gridX = this.x + x_offset;
                      const gridY = this.y - y_offset;
            
                      if (gridX < 0 || gridX >= GRID_WIDTH || gridY < 0 || gridY >= GRID_HEIGHT) return;
            
                      const block = new THREE.Group();
                      const cube = new THREE.Mesh(geometry, material);
                      const edges = new THREE.EdgesGeometry(geometry);
                      const wireframe = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xADFFFF, transparent: true, opacity: 0.6 }));
                      block.add(cube);
                      block.add(wireframe);
            
                      block.position.set(gridX + 0.5, gridY + 0.5, 0);
                      this.blocks.push(block);
                      gameWorld.add(block);
                    }
                  });
                });
            }
            
            removeFromScene() { this.blocks.forEach(b => gameWorld.remove(b)); this.blocks = []; }
            
            move(dx, dy) {
                if (isValidPosition(this.shape, this.x + dx, this.y + dy)) {
                    this.x += dx;
                    this.y += dy;
                    this.updatePosition();
                    return true;
                }
                return false;
            }

            rotate() {
                const newShape = this.shape[0].map((_, col) => this.shape.map(row => row[col]).reverse());
                const kicks = [0, 1, -1, 2, -2]; 

                for (const kick of kicks) {
                    if (isValidPosition(newShape, this.x + kick, this.y)) {
                        this.x += kick;
                        this.shape = newShape;
                        this.draw();
                        playSound('rotate');
                        return;
                    }
                }
            }

            updatePosition() {
                let blockIndex = 0;
                this.shape.forEach((row, y_offset) => {
                    row.forEach((value, x_offset) => {
                        if (value && this.blocks[blockIndex]) {
                            const gridX = this.x + x_offset;
                            const gridY = this.y - y_offset;
                            this.blocks[blockIndex].position.set(gridX + 0.5, gridY + 0.5, 0);
                            blockIndex++;
                        }
                    });
                });
            }
        }

        function spawnNewPiece() {
            const type = PIECE_TYPES[Math.floor(Math.random() * PIECE_TYPES.length)];
            const template = TETROMINOES[type];
            const x = Math.floor(GRID_WIDTH / 2) - Math.floor(template.shape[0].length / 2);
            const y = GRID_HEIGHT - 1;

            if (!isValidPosition(template.shape, x, y)) {
                gameOver();
                return;
            }
            currentPiece = new Tetromino(template.shape, template.color, x, y);
        }
        
        function placePiece() {
            if (!currentPiece) return;
            playSound('drop');
            currentPiece.shape.forEach((row, yOffset) => {
                row.forEach((value, xOffset) => {
                    if (value === 1) {
                        const gridX = currentPiece.x + xOffset;
                        const gridY = currentPiece.y - yOffset;
                        if (gridY >= 0 && gridY < GRID_HEIGHT) {
                            logicalGrid[gridY][gridX] = currentPiece.color;
                        }
                    }
                });
            });

            currentPiece.removeFromScene();
            clearLines();
            redrawGrid();
            spawnNewPiece();
        }
        
        function clearLines() {
            let linesCleared = 0;
            let newGrid = [];
            
            for (let i = 0; i < logicalGrid.length; i++) {
                if (!logicalGrid[i].every(cell => cell !== 0)) {
                    newGrid.push(logicalGrid[i]);
                } else {
                    linesCleared++;
                }
            }

            if (linesCleared > 0) {
                 for (let i = 0; i < linesCleared; i++) {
                    newGrid.push(Array(GRID_WIDTH).fill(0));
                }
                logicalGrid = newGrid;

                playSound(linesCleared === 4 ? 'tetris' : 'clear');
                lines += linesCleared;
                score += [0, 100, 300, 500, 800][linesCleared] * level;
                
                const newLevel = Math.floor(lines / 10) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    dropInterval = Math.max(100, 1000 - (level - 1) * 75); 
                }
                updateUI();
            }
        }
        
        function redrawGrid() {
            visualBlocks.forEach(block => gameWorld.remove(block));
            visualBlocks = [];
            logicalGrid.forEach((row, y) => {
                row.forEach((color, x) => {
                    if(color !== 0) {
                        const cubeGap = 0.04;
                        const geometry = new THREE.BoxGeometry(1 - cubeGap, 1 - cubeGap, 1 - cubeGap);
                        const material = new THREE.MeshLambertMaterial({ color, emissive: color, emissiveIntensity: 1.3 });
                        const block = new THREE.Group();
                        const cube = new THREE.Mesh(geometry, material);
                        
                        const edges = new THREE.EdgesGeometry(geometry);
                        const wireframe = new THREE.LineSegments( edges, new THREE.LineBasicMaterial({ color: 0xADFFFF, transparent: true, opacity: 0.6 }));
                        block.add(cube);
                        block.add(wireframe);

                        block.position.set(x + 0.5, y + 0.5, 0);
                        visualBlocks.push(block);
                        gameWorld.add(block);
                    }
                });
            });
        }

        function updateUI() {
            ui.highscore.textContent = highScore;
            ui.score.textContent = score;
            ui.lines.textContent = lines;
            ui.level.textContent = level;
        }

        function softDrop() { if (gameState !== 'playing' || !currentPiece) return; if (!currentPiece.move(0, -1)) placePiece(); else lastDropTime = performance.now(); }
        
        // --- FIX ---
        // Corrected the typo 'placePiec e' to 'placePiece'
        function hardDrop() { if (gameState !== 'playing' || !currentPiece) return; while(currentPiece.move(0, -1)); placePiece(); }

        // --- CONTROLS ---
        function addControls() {
            window.addEventListener('keydown', e => {
                if (gameState !== 'playing' || !currentPiece) return;
                switch (e.key) {
                    case 'ArrowLeft': currentPiece.move(-1, 0); playSound('move'); break;
                    case 'ArrowRight': currentPiece.move(1, 0); playSound('move'); break;
                    case 'ArrowUp': currentPiece.rotate(); break; 
                    case 'ArrowDown': softDrop(); break;
                    case ' ': e.preventDefault(); hardDrop(); break;
                }
            });
            
            let touchStartX = 0, touchStartY = 0, touchMoved = false;
            gameContainer.addEventListener('touchstart', e => {
                if (gameState !== 'playing' || e.touches.length === 0 || !currentPiece) return;
                touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY; touchMoved = false;
            }, { passive: true });

            gameContainer.addEventListener('touchmove', e => {
                if (gameState !== 'playing' || e.touches.length === 0 || !currentPiece) return;
                e.preventDefault(); // Prevent screen scroll
                const deltaX = e.touches[0].clientX - touchStartX;
                const deltaY = e.touches[0].clientY - touchStartY;

                // Prioritize horizontal movement
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 30) {
                    currentPiece.move(deltaX > 0 ? 1 : -1, 0); playSound('move');
                    touchStartX = e.touches[0].clientX; // Reset start X
                    touchStartY = e.touches[0].clientY; // Reset start Y
                    touchMoved = true;
                } 
                // Check for soft drop (vertical swipe)
                else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY > 20) {
                     softDrop();
                     touchStartX = e.touches[0].clientX;
                     touchStartY = e.touches[0].clientY;
                     touchMoved = true;
                }
            }, { passive: false }); // Set passive to false to allow preventDefault

            gameContainer.addEventListener('touchend', e => {
                if (gameState !== 'playing' || !currentPiece) return;
                
                // Check if it was a swipe or a tap
                if (touchMoved) {
                    // Check for hard drop (long vertical swipe)
                    const deltaY = e.changedTouches[0].clientY - touchStartY;
                    if (deltaY > 100) {
                        hardDrop();
                    }
                } else {
                    // If no significant movement, register as a tap (rotate)
                    currentPiece.rotate();
                }
                touchMoved = false; // Reset for next touch
            });
        }

        // --- ANIMATION & RESIZE ---
        function animate(time) {
            requestAnimationFrame(animate);
            if (!renderer) return; // Exit if init failed

            if (gameState === 'playing' && currentPiece && time - lastDropTime > dropInterval) {
                if (!currentPiece.move(0, -1)) {
                    placePiece();
                }
                lastDropTime = time;
            }

            // Idle animation for start/game over screens
            if (gameState !== 'playing') {
                const loopTime = time * 0.0001;
                camera.position.x = Math.sin(loopTime) * 5;
                camera.position.y = Math.cos(loopTime) * 5;
                camera.lookAt(scene.position);
            }
            
            if (stars && nebula && spaceDust) {
                const timeSeconds = time * 0.001;
                stars.rotation.y += stars.userData.speed * 0.05;
                nebula.rotation.y += nebula.userData.speed * 0.05;
                spaceDust.rotation.y += spaceDust.userData.speed * 0.05;
                nebula.material.opacity = Math.sin(timeSeconds * 0.5) * 0.15 + 0.55;
                nebula.material.color.setHSL(0.83 + Math.sin(timeSeconds * 0.1) * 0.1, 1.0, 0.6); 
            }
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;

            const margin = 1;
            const halfWidthInGrid = (GRID_WIDTH / 2) + margin;
            const halfHeightInGrid = (GRID_HEIGHT / 2) + margin;

            if (halfWidthInGrid / halfHeightInGrid > aspect) {
                camera.left = -halfWidthInGrid;
                camera.right = halfWidthInGrid;
                camera.top = halfWidthInGrid / aspect;
                camera.bottom = -halfWidthInGrid / aspect;
            } else {
                camera.top = halfHeightInGrid;
                camera.bottom = -halfHeightInGrid;
                camera.left = -halfHeightInGrid * aspect;
                camera.right = halfHeightInGrid * aspect;
            }

            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Wait for the window to load before trying to init the game
        // This ensures that THREE and Tone are defined (if loaded correctly)
        window.addEventListener('load', () => {
            // Check if libraries are loaded
            if (typeof THREE === 'undefined' || typeof Tone === 'undefined') {
                console.error("Failed to load libraries (THREE or Tone).");
                document.body.innerHTML = `<div style="padding: 20px; text-align: center; font-size: 18px; color: red; font-family: monospace;">
                    <h1>Error</h1>
                    <p>Could not load game libraries (three.js or tone.js).</p>
                    <p>Please check your internet connection and try again.</p>
                    </div>`;
                return;
            }
            
            try {
                init();
            } catch (e) {
                console.error("Failed to initialize game:", e);
                // Display a friendly error to the user
                document.body.innerHTML = `<div style="padding: 20px; text-align: center; font-size: 18px; color: red; font-family: monospace;">
                        <h1>Error</h1>
                        <p>An unexpected error occurred while starting the game.</p>
                        <p><i>Details: ${e.message}</i></p>
                        </div>`;
            }
        });
    </script>
</body>
</html>
